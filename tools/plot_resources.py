#!/usr/bin/env python3
"""
Container Resource Visualization Script

Reads CSV data generated by monitor_resources.sh and creates time-series plots
showing CPU and memory usage over time.

Usage: python plot_resources.py [OPTIONS] CSV_FILE
"""

import argparse
import sys
from pathlib import Path
from datetime import datetime

try:
    import pandas as pd
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
except ImportError as e:
    print(f"Error: Missing required dependency: {e}", file=sys.stderr)
    print("\nInstall dependencies with:", file=sys.stderr)
    print("  uv pip install matplotlib pandas", file=sys.stderr)
    sys.exit(1)


def parse_memory_value(mem_str: str) -> float:
    """
    Parse memory string (e.g., '45.5MiB', '1.2GiB') to float in MiB.
    
    Args:
        mem_str: Memory string with unit suffix
        
    Returns:
        Memory value in MiB
    """
    mem_str = mem_str.strip()
    
    # Handle different units
    if mem_str.endswith('GiB'):
        return float(mem_str[:-3]) * 1024
    elif mem_str.endswith('MiB'):
        return float(mem_str[:-3])
    elif mem_str.endswith('KiB'):
        return float(mem_str[:-3]) / 1024
    elif mem_str.endswith('B'):
        return float(mem_str[:-1]) / (1024 * 1024)
    else:
        # Try to parse as plain number (assume MiB)
        try:
            return float(mem_str)
        except ValueError:
            return 0.0


def load_data(csv_file: Path) -> pd.DataFrame:
    """
    Load and parse CSV data.
    
    Args:
        csv_file: Path to CSV file
        
    Returns:
        Parsed DataFrame with datetime index
    """
    df = pd.read_csv(csv_file)
    
    # Parse timestamp
    df['Timestamp'] = pd.to_datetime(df['Timestamp'])
    
    # Parse CPU% (remove '%' if present and convert to float)
    df['CPU%'] = df['CPU%'].astype(float)
    
    # Parse memory percentage
    df['Mem%'] = df['Mem%'].astype(float)
    
    # Parse memory usage (convert to MiB)
    df['MemUsage_MiB'] = df['MemUsage'].apply(parse_memory_value)
    
    return df


def plot_resources(df: pd.DataFrame, output_file: Path = None, title: str = None):
    """
    Create time-series plot of CPU and memory usage.
    
    Args:
        df: DataFrame with resource usage data
        output_file: Optional output file path
        title: Optional custom title
    """
    containers = df['Container'].unique()
    num_containers = len(containers)
    
    # Create figure with subplots
    fig, axes = plt.subplots(num_containers, 1, figsize=(14, 6 * num_containers))
    
    # Handle single container case (axes won't be an array)
    if num_containers == 1:
        axes = [axes]
    
    for idx, container in enumerate(containers):
        container_data = df[df['Container'] == container].copy()
        container_data = container_data.sort_values('Timestamp')
        
        ax1 = axes[idx]
        
        # Plot CPU on primary y-axis
        color1 = 'tab:blue'
        ax1.set_xlabel('Time')
        ax1.set_ylabel('CPU %', color=color1)
        line1 = ax1.plot(container_data['Timestamp'], container_data['CPU%'], 
                        color=color1, label='CPU %', linewidth=2)
        ax1.tick_params(axis='y', labelcolor=color1)
        ax1.grid(True, alpha=0.3)
        
        # Plot memory on secondary y-axis
        ax2 = ax1.twinx()
        color2 = 'tab:red'
        ax2.set_ylabel('Memory %', color=color2)
        line2 = ax2.plot(container_data['Timestamp'], container_data['Mem%'], 
                        color=color2, label='Memory %', linewidth=2, linestyle='--')
        ax2.tick_params(axis='y', labelcolor=color2)
        
        # Format x-axis
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        ax1.xaxis.set_major_locator(mdates.AutoDateLocator())
        plt.setp(ax1.xaxis.get_majorticklabels(), rotation=45, ha='right')
        
        # Add legend
        lines = line1 + line2
        labels = [l.get_label() for l in lines]
        ax1.legend(lines, labels, loc='upper left')
        
        # Set title
        container_title = f'Resource Usage: {container}'
        if title:
            container_title = f'{title}: {container}'
        ax1.set_title(container_title, fontsize=14, fontweight='bold')
        
        # Add statistics text
        avg_cpu = container_data['CPU%'].mean()
        max_cpu = container_data['CPU%'].max()
        avg_mem = container_data['Mem%'].mean()
        max_mem = container_data['Mem%'].max()
        
        stats_text = f'CPU: avg={avg_cpu:.1f}%, max={max_cpu:.1f}% | Memory: avg={avg_mem:.1f}%, max={max_mem:.1f}%'
        ax1.text(0.02, 0.98, stats_text, transform=ax1.transAxes, 
                fontsize=10, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    plt.tight_layout()
    
    # Save or show
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Plot saved to: {output_file}")
    else:
        plt.show()


def main():
    parser = argparse.ArgumentParser(
        description='Visualize container resource usage from CSV data',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate plot and display
  python plot_resources.py resource_usage.csv
  
  # Save to file
  python plot_resources.py resource_usage.csv -o output.png
  
  # Custom title
  python plot_resources.py resource_usage.csv -t "LSA-only Test"
        """
    )
    
    parser.add_argument('csv_file', type=Path, help='Input CSV file from monitor_resources.sh')
    parser.add_argument('-o', '--output', type=Path, help='Output image file (PNG, PDF, etc.)')
    parser.add_argument('-t', '--title', help='Custom title for the plot')
    
    args = parser.parse_args()
    
    # Validate input file
    if not args.csv_file.exists():
        print(f"Error: CSV file not found: {args.csv_file}", file=sys.stderr)
        sys.exit(1)
    
    # Load data
    try:
        print(f"Loading data from {args.csv_file}...")
        df = load_data(args.csv_file)
        print(f"Loaded {len(df)} records for {df['Container'].nunique()} container(s)")
    except Exception as e:
        print(f"Error loading CSV file: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Create plot
    try:
        print("Generating plot...")
        plot_resources(df, args.output, args.title)
        
        if not args.output:
            print("\nDisplaying plot (close window to exit)...")
    except Exception as e:
        print(f"Error creating plot: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
